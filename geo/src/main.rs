// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Copyright © 2024 RemasteredArch
//
// This file is part of ip_geo.
//
// ip_geo is free software: you can redistribute it and/or modify it under the terms of the GNU
// Affero General Public License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// ip_geo is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
// even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License along with ip_geo. If
// not, see <https://www.gnu.org/licenses/>.

use std::{
    fmt::Display,
    process::{Command, Output},
    str::{self, FromStr},
};

use chrono::{SecondsFormat, Utc};

/// Represents all possible error states of this module.
#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error(transparent)]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    StrFromUtf8(#[from] core::str::Utf8Error),

    #[error("can't parse line '{0}' into Country")]
    InvalidCountryLine(Box<str>),

    #[error("expected two letter country code, received '{0}'")]
    InvalidCode(Box<str>),
}

fn main() {
    let additional_countries = vec![Country::new("??", "Unknown")];
    let countries = get_country_list(additional_countries).unwrap();

    // dbg!(&countries);
    // print_country_list_as_code_and_name(&countries);
    print_country_list_as_rust_hashmap(&countries);
}

/// Formats and prints a list of countries' codes and names separated by a space
///
/// For exmaple:
///
/// ```text
/// AP Asia/Pacific
/// BE Belgium
/// CS Serbia and Montenegro
/// ?? Unkown
/// ```
#[allow(dead_code)]
fn print_country_list_as_code_and_name(countries: &[Country]) {
    countries
        .iter()
        .for_each(|c| println!("{} {}", c.code, c.name));
}

/// Formats prints a list of countries as valid Rust code that returns a `HashMap`.
#[allow(dead_code)]
fn print_country_list_as_rust_hashmap(countries: &[Country]) {
    print!(
        r#"// This file was @generated by `ip_geo::geo` at {}. Do not edit!

// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Copyright © 2024 RemasteredArch
//
// This file is part of ip_geo.
//
// ip_geo is free software: you can redistribute it and/or modify it under the terms of the GNU
// Affero General Public License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// ip_geo is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
// even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License along with ip_geo. If
// not, see <https://www.gnu.org/licenses/>.

use std::collections::HashMap;

/// A map of countries, with the ISO 3166-1 alpha-2 code as the key.
#[rustfmt::skip]
pub fn get_countries() -> HashMap<String, String> {{HashMap::from([
"#,
        Utc::now().to_rfc3339_opts(SecondsFormat::Secs, true) // Ex. 2024-07-21T04:11:07Z
    );

    countries
        .iter()
        .for_each(|c| println!("    {},", c.as_rust_map_entry()));

    println!("])}}");
}

/// Represents a country and its ISO 3166-1 alpha-2 code, alongside a Wikidata ID (if available).
#[derive(Debug)]
#[allow(dead_code)]
struct Country {
    name: Box<str>, // Ex. Belgium
    code: Box<str>, // Ex. BE
}

impl Country {
    /// Create a new country without a Wikidata ID.
    fn new(code: impl AsRef<str>, name: impl AsRef<str>) -> Self {
        Self {
            name: name.as_ref().into(),
            code: code.as_ref().into(),
        }
    }

    /// Formats contents as a valid entry of `CountryData` in a `HashMap`.
    ///
    /// Example usage:
    ///
    /// ```rust
    /// assert_eq!(
    ///     Country::new("EX", "Example").as_rust_map_entry().as_ref(),
    ///     r#"("EX".into(), "Example".into())"#
    /// );
    /// ```
    fn as_rust_map_entry(&self) -> Box<str> {
        let (code, name) = self.contents_as_strings();

        format!("({code}, {name})").into_boxed_str()
    }

    /// Returns self as a tuple of four Strings holding string literals: `(code, name)`
    ///
    /// Example usage:
    ///
    /// ```
    /// assert_eq!(
    ///     Country::new_without_id("EX", "Example").contents_as_strings()
    ///     ("\"EX\".into()", "\"Example\".into()")
    /// );
    /// ```
    fn contents_as_strings(&self) -> (Box<str>, Box<str>) {
        /// Wraps a string in double quotes.
        fn as_str<T: Display>(str: T) -> Box<str> {
            format!("\"{}\".into()", str).into_boxed_str()
        }

        let (code, name) = self.as_tuple();

        (as_str(code), as_str(name))
    }

    /// Returns the struct's internal fields as a tuple: `(code, name)`
    ///
    /// ```rust
    /// assert_eq!(
    ///     Country::new("EX", "Example").as_tuple(),
    ///     (Box::new("EX"), Box::new("Example"))
    /// );
    /// ```
    fn as_tuple(&self) -> (Box<str>, Box<str>) {
        (self.code.clone(), self.name.clone())
    }
}

impl FromStr for Country {
    type Err = Error;

    /// Parse a line into a `Country`.
    ///
    /// Expects a two letter line in this format:
    ///
    /// ```text
    /// cc country name
    /// ```
    ///
    /// Where `cc` is a two letter country code, and `country name` is an arbitrary string.
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (code, name) = s
            .split_once(' ')
            .ok_or(Error::InvalidCountryLine(s.into()))?;

        if code.len() != 2 {
            return Err(Error::InvalidCode(code.into()));
        }

        Ok(Self::new(code, name))
    }
}

/// Returns a list of countries.
///
/// Sourced from [`location(8)`](https://man-pages.ipfire.org/libloc/location.html)
/// and `additional_countries`.
fn get_country_list(mut additional_countries: Vec<Country>) -> Result<Box<[Country]>, Error> {
    let input = call_location()?;
    let mut countries = Vec::with_capacity(input.len() + additional_countries.len());

    for line in input {
        if line.len() == 0 {
            continue;
        }

        // Alternatively, this could bubble up an error
        match Country::from_str(&line) {
            Ok(country) => countries.push(country),
            Err(error) => eprintln!("Error parsing country list: {error}"),
        }
    }

    countries.append(&mut additional_countries);
    countries.dedup_by_key(|c| c.code.clone());

    Ok(countries.into_boxed_slice())
}

fn call_location() -> Result<Vec<Box<str>>, Error> {
    let output = call("location list-countries --show-name")?;

    // Split into lines
    // Is this broken by Windows' CRLF?
    let output = output.stdout.split(|c| *c == b'\n');

    // Parse each line from bytes into strings
    // What can I do about that unwrap?
    let lines = output.map(|s| str::from_utf8(s).unwrap().into());

    Ok(lines.collect())
}

/// Make a shell call.
///
/// On Windows:
/// ```cmd
/// cmd /C command
/// ```
///
/// On POSIX:
/// ```sh
/// sh -c command
/// ```
fn call(command: &str) -> Result<Output, Error> {
    if cfg!(target_os = "windows") {
        Ok(Command::new("cmd").args(["/C", command]).output()?)
    } else {
        Ok(Command::new("sh").args(["-c", command]).output()?)
    }
}
